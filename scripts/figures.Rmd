---
title: "Figures"
author: "JT McCrone"
date: "December 30, 2015"
output: html_document
---
```{r,settings_and_lib}
require(ggplot2)
require("plyr")
require("Biostrings")
require(reshape2)
require("pROC")
require(gridExtra)
theme_set(new = theme_classic(base_size=24))
```


## 1) Miseq out of the box
### ROC skematic
```{r, roc_skematic}
set.seed(42) # make the figures reproducible
example<-data.frame(Condition=c(rep(x = c(TRUE,FALSE),each=20)),test=c(runif(20,-10,-4),runif(20,-6,0))) # Make a dataframe of T and F positives with random p values that favors a lower distribution for the TP
ex.roc<-roc(example$Condition~example$test) # make an ROC based on this data

cord<-coords(ex.roc,x="all") # get the coordinates of the ROC
cord.l<-melt(cord) # melt the coodinates for ease of plotting
cord.l<- mutate(cord.l,Id=c(0,head(as.numeric(rownames(cord.l))%/%3,-1))) # Add an Id so that the specificity and sensitivity at a given threshold can be groupled together

# Set an id column to group the threshold,specificity, and sensitivity together with the same number by integer division. I adjust with c(0, head ..., -1) since 3%/%3=1 but it should be grouped with the 0's.
roc.df<-dcast(cord.l,Id~Var1) # dcast into columns of threshold, specificity and sensitivity
roc.df<-roc.df[order(roc.df$sensitivity),] # So that the points connect nicely

# Plot the roc to be used later
roc.p<-ggplot(roc.df,aes(x=1-specificity,y=sensitivity))+geom_step(color="black",size=2)+xlab("1-Specificity")+ylab("Sensitivity")+theme(axis.title.y=element_text(vjust=1))

# png("../../Talks/figures/roc.ex.png")
# roc.p
# dev.off()

# plot the point distribution to be used later
points.p<-ggplot(example,aes(x=1,y=test,fill=Condition))+geom_dotplot(binaxis = "y", stackdir = "center")+scale_fill_manual(values=c("white","black"),name="",breaks=c(T,F),labels=c("True Positive","False Positive"))+xlab("")+ylab("Log(p value)")+theme(axis.ticks = element_blank(), axis.text.x = element_blank())


#+scale_fill_brewer(palette="Set1")#+theme(text = element_text(size=30))

#This function takes in a specificity and adds lines indicating where this specificity is found on the ROC plotted above
plot.roc<-function(x){ 
  above.sense.cut<-subset(roc.df,specificity>=x,select=c(threshold,specificity,sensitivity)) # get the points where specificity is above the cutoff
  sense.min<-min(above.sense.cut$specificity) # get the minimum of these to get as close to desired sensitivity as possible
  sense.cut<-subset(above.sense.cut,specificity==sense.min) # get all rows where sensitivity is at this point
  spec.max<-max(sense.cut$sensitivity) # but there can be different FPR for each TPR so here we maximize specificity
  output<-subset(sense.cut,sensitivity==spec.max)
  lines<-data.frame(sense=c(output$sensitivity,output$sensitivity,0), # make a data frame with the coordinates for the lines whicha re to be added
                    spec=c(0,1-output$specificity,1-output$specificity))
  p1<-roc.p+geom_line(data=lines,aes(x=spec,y=sense),size=1.5,lty=2)+xlab("1-Specificity")+ylab("Sensitivity") # plot
    
  p1<-p1+theme(axis.title.y = element_text(vjust=1.2))+theme(axis.title.x = element_text(vjust=0))
  print(p1)
}

#This function takes in a specificity and adds a line to show where this specificity is reached in the p value distribution above

plot.pv<-function(x){
  above.sense.cut<-subset(roc.df,specificity>=x,select=c(threshold,specificity,sensitivity)) # get the points where sensitivity is above the cutoff
  sense.min<-min(above.sense.cut$specificity) # get the minimum of these to get as close to desired sensitivity as possible
  sense.cut<-subset(above.sense.cut,specificity==sense.min) # get all rows where sensitivity is at this point
  spec.max<-max(sense.cut$sensitivity) # but there can be different FPR for each TPR so here we maximize specificity
  output<-subset(sense.cut,sensitivity==spec.max)
  p2<-points.p+geom_hline(yintercept=output$threshold,
                          size=1.5,lty=2)
  p2<-p2+scale_x_continuous(breaks=c(1),labels=c(""))
  p2<-p2+xlab("")+ylab("Log(p value)")
  p2<-p2+theme(axis.title.y = element_text(vjust=1.2))
  print(p2)
}

pdf("../results/figures/pv.1.pdf")
plot.pv(0.35)
dev.off()

pdf("../results/figuresROC.1.pdf")
plot.roc(0.35)
dev.off()

pdf("../results/figures/pv.2.pdf")
plot.pv(0.95)
dev.off()

pdf("../results/figures/ROC.2.pdf")
plot.roc(0.95)
dev.off()

```
Now it might also be useful to include a figure that has 2 cutoffs and outputs the plots side by side.

```{r,roc_skematic_onplot}
#Helper function that gets the threshold and sensitivity from and roc at a given speceificity
helper.roc<-function(spec,roc.df){
  above.sense.cut<-subset(roc.df,specificity>=spec,select=c(threshold,specificity,sensitivity)) # get the points where specificity is above the cutoff
  sense.min<-min(above.sense.cut$specificity) # get the minimum of these to get as close to desired sensitivity as possible
  sense.cut<-subset(above.sense.cut,specificity==sense.min) # get all rows where sensitivity is at this point
  spec.max<-max(sense.cut$sensitivity) # but there can be different FPR for each TPR so here we maximize specificity
  output<-subset(sense.cut,sensitivity==spec.max)
}

plot.ex<-function(spec1,spec2,roc.df,distribution){ 
  cut1<-helper.roc(spec1,roc.df)#dataframe with the threshold,sensitivity and specificity at the given specificity
  cut2<-helper.roc(spec2,roc.df)
  output<-rbind(cut1,cut2)
  lines<-data.frame(sense=c(output$sensitivity,output$sensitivity,0,0), # make a data frame with the coordinates for the lines whicha re to be added
                    spec=c(0,0,1-output$specificity,1-output$specificity), # really 1-specificity
                    group=rep(c(spec1,spec2),times=3))
  
  #plot the roc
  roc.p<-ggplot(roc.df,aes(x=1-specificity,y=sensitivity))+geom_step(color="black",size=2)+xlab("1-Specificity")+ylab("Sensitivity")+theme(axis.title.y=element_text(vjust=1))
  roc.p<-roc.p+geom_line(data=lines,aes(x=spec,y=sense,color=as.factor(group)),size=c(1.5),lty=c(2))+scale_color_brewer(palette="Set1")
    
 roc.p<-roc.p+theme(axis.title.y = element_text(vjust=1.2))+theme(axis.title.x = element_text(vjust=0))+theme(legend.position="none")
  
 
 #plot the points and cut offs
 points.p<-ggplot(distribution,aes(x=1,y=test,fill=Condition))+geom_dotplot(binaxis = "y", stackdir = "center")+scale_fill_manual(values=c("white","black"),name="",breaks=c(T,F),labels=c("True Positive","False Positive"))+xlab("")+ylab("Log(p value)")+theme(axis.ticks = element_blank(), axis.text.x = element_blank(),axis.title.y = element_text(vjust=1.2))
 
 points.p<-points.p+geom_hline(yintercept=output$threshold,
                          size=1.5,lty=2,color=c("#e41a1c","#377eb8")) # these are the first 2 colors in set 1
  
 grid.arrange(points.p,roc.p,ncol=2)
 
}
plot.ex(0.35,0.95,roc.df,example)

pdf("../results/figures/roc.example.pdf")
plot.ex(0.35,0.95,roc.df,example)
dev.off()

```
### Experimental setup diagram




### DeepSNV ROC 

```{r,roc_helper_runctions}
id<-function(x){
  x<-strsplit(x,".",fixed=T)[[1]][1]
}

seg<-function (x) {
  x <- strsplit(x, ".", fixed = T)[[1]][2]
}  

sum_roc<-function(x){
  sum.df<-subset(x,category %in% c(TRUE,FALSE),select=c(category,p.val))# get the TRUE and false variant calls and p.vals
  if(length(which(sum.df$category==T))>0){ # filter out cases where there aren't any TP found
    if(length(which(sum.df$category==F))==0){
      sum.df<-rbind(sum.df,data.frame(category=F,p.val=1))
    }  
    roc(sum.df$category~sum.df$p.val,plot=F,CI=T)
  }
}

roc_df<-function(roc_analysis){ # get the coordinates and cut offs for all the points in the ROC object
  roc_analysis<-roc_analysis[unlist(lapply(roc_analysis,is.null))==F]
  all<-lapply(roc_analysis,coords,x="all")
  all.long<-lapply(all, melt) 
  all.long<-lapply(all.long, function(x){ 
    mutate(x, 
           Id=c(0,head(as.numeric(rownames(x))%/%3,-1))
    )
  }) # Set an id column to group the threshold,specificity, and sensitivity together with the same number by integer division. I adjust with c(0, head ..., -1) since 3%/%3=1 but it should be grouped with the 0's.
  roc.ls<-lapply(all.long,function(x) dcast(x,Id~Var1)) # dcast into columns of threshold, specificity and sensitivity
  roc.df<-do.call(rbind,roc.ls) # combine into data frame
  roc.df$samp<-unlist(lapply(rownames(roc.df),id)) # add sample id column
  
  mutate(roc.df, exp.freq=find_freq.v(samp))-> roc.df
}  

adjust.coords<-function(roc.df,sum.df,possible_tp,possible_vars){ # adjust the sensitivity and specificity called by pROC  
  samp<-roc.df$samp[1]
  samp.df<-subset(sum.df,Id==samp)
  sense.factor<-length(which(samp.df$category==T))/possible_tp
  TN.samp<-length(which(samp.df$category==F))
  mutate(roc.df,adj.sensitivity=sensitivity*sense.factor,FP=(TN.samp-TN.samp*specificity),TP=sense.factor*possible_tp,adj.specificity=(possible_vars-possible_tp-FP)/((possible_vars-possible_tp)))
}
roc_df.one<-function(roc_analysis,thr){ # get the coordinates and cut offs for all the points in the ROC object
  roc_analysis<-roc_analysis[unlist(lapply(roc_analysis,is.null))==F]
  all<-lapply(roc_analysis,coords,x=thr,input="thr")

  #roc.ls<-lapply(all.long,function(x) dcast(x,Id~Var1)) # dcast into columns of threshold, specificity and sensitivity
  roc.df<-as.data.frame(do.call(rbind,all)) # combine into data frame
  roc.df$samp<-rownames(roc.df) # add sample id column
  
  mutate(roc.df, exp.freq=find_freq.v(samp))-> roc.df
} 
######### Miseq roc functions ##########
miseq.roc<-function(sum.df,possible_tp,possible_vars){ # A function to run the roc calculations and adjustments
  roc.ls<-dlply(sum.df,~Id,sum_roc)

  roc.df<-roc_df(roc.ls)


  roc.df.adj<-ddply(roc.df,~samp,adjust.coords,sum.df,possible_tp,possible_vars)
  roc.df.adj<-roc.df.adj[order(roc.df.adj$adj.sensitivity),]
  roc.df.adj<-mutate(roc.df.adj,exp.freq=as.factor(find_freq.v(samp)))
  roc.df.adj$exp.freq <- factor(roc.df.adj$exp.freq, levels = rev(levels(roc.df.adj$exp.freq)))
  return(roc.df.adj)
}
miseq.roc.table<-function(sum.df,cut.off,possible_tp,possible_vars){
  roc.ls<-dlply(sum.df,~Id,sum_roc)
  roc.df<-roc_df.one(roc.ls,cut.off)
  roc.df.adj<-ddply(roc.df,~samp,adjust.coords,sum.df,possible_tp,possible_vars)
  roc.df.adj<-roc.df.adj[order(roc.df.adj$exp.freq,decreasing = T),]
  roc.table<-subset(roc.df.adj,select=c(exp.freq,adj.sensitivity,TP,adj.specificity,FP))
  return(roc.table)
}


######### Hiseq roc functions ##########
hiseq.roc<-function(sum.df,possible_tp,possible_vars){ # A function to run the roc calculations and adjustments
  roc.ls<-dlply(sum.df,~Id,sum_roc)

  roc.df<-roc_df(roc.ls)


  roc.df.adj<-ddply(roc.df,~samp,adjust.coords,sum.df,possible_tp,possible_vars)
  roc.df.adj<-roc.df.adj[order(roc.df.adj$adj.sensitivity),]

  mutate(roc.df.adj, gc = as.numeric(sub(pat,"\\1",samp)),
       exp.freq = sub(pat,"\\2",samp)
  )-> roc.df.adj
  mutate(roc.df.adj,exp.freq=ifelse(test = grepl("0",exp.freq),yes=as.numeric(exp.freq)/1000,no = as.numeric(exp.freq)/100))->roc.df.adj
  roc.df.adj$exp.freq<-as.factor(roc.df.adj$exp.freq)
  roc.df.adj$exp.freq <- factor(roc.df.adj$exp.freq, levels = rev(levels(roc.df.adj$exp.freq)))
  return(roc.df.adj)
}

hiseq.roc.table<-function(sum.df,cut.off,possible_tp,possible_vars){
  roc.ls<-dlply(sum.df,~Id,sum_roc)
  roc.df<-roc_df.one(roc.ls,cut.off)
  roc.df.adj<-ddply(roc.df,~samp,adjust.coords,sum.df,possible_tp,possible_vars)
mutate(roc.df.adj, gc = as.numeric(sub(pat,"\\1",samp)),
       exp.freq = sub(pat,"\\2",samp)
)-> roc.df.adj
mutate(roc.df.adj,exp.freq=ifelse(test = grepl("0",exp.freq),yes=as.numeric(exp.freq)/1000,no = as.numeric(exp.freq)/100))->roc.df.adj
roc.df.adj<-roc.df.adj[order(roc.df.adj$exp.freq,decreasing = T),]
roc.table<-subset(roc.df.adj,select=c(gc,exp.freq,adj.sensitivity,TP,adj.specificity,FP))
return(roc.table)
}
```

```{r,Miseq_out_of_the_box}
find_freq<-function(Id){ # helper function to get the expected frequency from the sample name
  if(Id=="Covaris_5"){
    x=0.05} else if ( Id=="Covaris_25"){
    x=0.025} else if ( Id=="Covaris_125"){
    x=0.0125} else if ( Id=="Covaris_063"){
    x=0.0063} else if ( Id=="Covaris_016"){
    x=0.0016}
}
find_freq.v<-Vectorize(find_freq) # vectorized version of the helper function above



sum.df<-read.csv("../data/process/2014-5-30/one.sided/Variants/all.sum.csv",stringsAsFactors=F,comment.char = '#')
  
true_snv<-read.csv("../data/reference/PR8_WSN33.csv",comment.char = '#') # read in a csv of the differences in PR8 and WSN33 as determined by sanger
true_snv<-subset(true_snv,Ref!="-" & Allele.1!="-") # remove any indels as we are not concerned with them here
mutate(true_snv,mutant=paste0(Name,"_",Ref,Ref.Pos,Allele.1))->true_snv #make a column that has names the variants as segment_ReferencePositionVariant
true_snv<-rename(true_snv,c("Name"="chr","Ref.Pos"="pos")) # rename the columns for use later
PR8_var<-read.csv("../data/reference/PR8_variants.csv",comment.char = "#") # read in differences between plasmid control on viral PR8 used in dilutions


mutate(PR8_var,mutant=paste0(Name,"_",Ref,Ref.Pos,Allele.1))->PR8_var #make a column that has names the variants as segment_ReferencePositionVariant
PR8_var<-rename(PR8_var,c("Name"="chr","Ref.Pos"="pos")) # rename the columns for use later  
sum.df<-mutate(sum.df,category=mutation %in% true_snv$mutant) # add Column for True and false variants to variant calls
sum.df$category[sum.df$mutation %in% PR8_var$mutant]<-"PR8" # id the variants found in PR8
sum.df<-mutate(sum.df,exp.freq=find_freq.v(Id)) # add the expected frequency of the true variants


# Get information about the regions we can investigate based on the primer sites


regions.bed <-read.csv("../data/reference/pr8_noprimingsites.bed.csv",stringsAsFactors = F,comment.char = "#")
regions.bed<-mutate(regions.bed,length=stop-start-1) #because the numbers in the csv are the inner most binding sites of the primers and represent the last positiions that cannot be interogated.

possible_vars<-sum(regions.bed$length)*3 # three possible variants/ position

# limit the PR8 and the true positive data.frames to those not excluded by the priming sites

primer.cut<-function(x){ # a helper function to do this
  chr<-unique(x$chr)
  start<-regions.bed$start[match(x$chr,regions.bed$chr)]
  stop<-regions.bed$stop[match(x$chr,regions.bed$chr)]
  
  subset(x,pos>start & pos<stop)
}
sum.df<-ddply(sum.df,~chr,primer.cut) # interogating only the sites within primer location removes 244 called variants for two sided and 406 for one sided test
true_snv<-ddply(true_snv,~chr,primer.cut) # interogating only the sites within primer location removes 8 potential true positive (491)
PR8_var<-ddply(PR8_var,~chr,primer.cut) # interogating only the sites within primer location removes 12 potential PR8 differences (15)



## These functions make an ROC by allowing pROC to calculate the positions based on only the variants that are provided, and then we adjust the senesitivity for with what we know.  For example if only 3 TP are found in one sample pROC will call that 100% Sensitivity but we will adjust it to 3/possible_tp and so forth.

tp<-unique(true_snv$mutant)
possible_tp<-length(tp)


m.roc.df<-miseq.roc(sum.df,possible_tp,possible_vars)

miseq.roc<-ggplot(m.roc.df,aes(x=1-adj.specificity,y=adj.sensitivity))+geom_step(aes(color=exp.freq),size=2)+scale_color_brewer(palette = "Set1")+xlab("1-Specificity")+ylab("Sensitivity")+guides(color=guide_legend(title="Frequency"))+scale_y_continuous(limits=c(0,1))#+scale_x_continuous(limits=c(0,0.001))

miseq.roc

# pdf("../results/figures/miseq_roc.one.sided.pdf")
# miseq.roc
# dev.off()

m.roc.table<-miseq.roc.table(sum.df,0.001,possible_tp,possible_vars)
knitr::kable(m.roc.table)

rm(list = setdiff(ls(), lsf.str())) # remove all variables except the functions
```


## 2) Hiseq out of the box

### ROC

```{r,hiseq_roc}
sum.df<-read.csv("../data/process/2015-6-23/Variants/all.sum.csv",stringsAsFactors = F,comment.char = "#") # reading in the variants from the pipeline output

# Getting genome lenght and segment information from the wsn33 fasta file
reference.fasta<-"../data/reference/wsn33_wt_plasmid.fa" 
segments <- fasta.seqlengths(reference.fasta)
regions.bed <- data.frame(chr = gsub("[ ].*","", names(segments)), start=12, stop=segments-13, row.names=NULL) # the univeral primers are 12 and 13 bp long
regions.bed<-mutate(regions.bed,chr=as.character(chr))

# The samples are named in the following format log(genome copy/ul)_expected frequency of variants We'll use that information here to get the gc# and exp.freq for each variant called

pat<-"([0-9]+)_([0-9]+)" 
mutate(sum.df, gc = sub(pat,"\\1",Id),
       exp.freq = sub(pat,"\\2",Id)
)-> sum.df
mutate(sum.df,exp.freq=ifelse(test = grepl("0",exp.freq),yes=as.numeric(exp.freq)/1000,no = as.numeric(exp.freq)/100))->sum.df

# Id the variants as T or F 
true_snv<-read.csv("../data/reference/mutant_id.csv",stringsAsFactor=F) # get the T variants
sum.df<-mutate(sum.df,category=mutation %in% true_snv$mutant) # add Column for True and false variants
wt1_mut<-subset(sum.df,Id=="WT1",select=mutation)
wt2_mut<-subset(sum.df,Id=="WT2",select=mutation)

wt_mut<-intersect(wt1_mut$mutation,wt2_mut$mutation)

length(wt_mut)
sum.df$category[sum.df$mutation %in% wt_mut]<-"wt"
sum.df<-subset(sum.df,!(grepl("WT",Id))) # remove the WT samples

possible_tp<-20 # there are 20 possible true positives in the mix
regions.bed<-mutate(regions.bed,length=stop-start-1) #because the numbers in the csv are the inner most binding sites of the primers and represent the last positiions that cannot be interogated.

possible_vars<-sum(regions.bed$length)*3 # three possible variants/ position


h.roc.df<-hiseq.roc(sum.df,possible_tp,possible_vars)

Hiseq.roc<-ggplot(subset(h.roc.df,gc==5),aes(x=1-adj.specificity,y=adj.sensitivity))+geom_step(aes(color=exp.freq),size=2)+scale_color_brewer(palette = "Set1")+xlab("1-Specificity")+ylab("Sensitivity")+guides(color=guide_legend(title="Frequency"))+scale_y_continuous(limits=c(0,1));Hiseq.roc

h.table.df<-hiseq.roc.table(sum.df,0.001,possible_tp,possible_vars)

knitr::kable(subset(h.table.df,gc==5))
```

## 3) Phred and MapQ filters

```{r, phred_mapq filter}
ggplot(subset(sig.df,gc==5 & category %in% c(T,F)),aes(x=Phred,y=MapQ,color=category))+geom_point()

sig.df<-subset(sum.df,p.val<0.001)

ggplot(subset(sig.df,gc==5 & category %in% c(T,F)),aes(x=Phred,y=MapQ,color=category))+geom_point()

cut.df<-subset(sum.df,MapQ>30 & Phred>35)

h.cut.df<-hiseq.roc(cut.df,possible_tp,possible_vars)

ggplot(subset(h.cut.df,gc==5),aes(x=1-adj.specificity,y=adj.sensitivity))+geom_step(aes(color=exp.freq),size=2)+scale_color_brewer(palette = "Set1")+xlab("1-Specificity")+ylab("Sensitivity")+guides(color=guide_legend(title="Frequency"))+scale_y_continuous(limits=c(0,1))


h.cut.table<-hiseq.roc.table(cut.df,0.001,possible_tp,possible_vars)

knitr::kable(subset(h.cut.table,gc==4))
```

## 4) Read position

```{r,read_pos}
ggplot(sig.df,aes(x=pos,y=Read_pos,color=category))+geom_point()+facet_wrap(~chr)
ggplot(subset(sig.df,gc==5),aes(x=pos,y=Read_pos,color=category))+geom_point()+facet_wrap(~chr)

ggplot(cut.df,aes(x=pos,y=Read_pos,color=category))+geom_point()+facet_wrap(~chr)
ggplot(subset(cut.df,gc==5),aes(x=pos,y=Read_pos,color=category))+geom_point()+facet_wrap(~chr)

sig.cut.df<-subset(cut.df,p.val<0.001)

ggplot(sig.cut.df,aes(x=pos,y=Read_pos,color=category))+geom_point()+facet_wrap(~chr)
ggplot(subset(sig.cut.df,gc==5),aes(x=pos,y=Read_pos,color=category))+geom_point()+facet_wrap(~chr)


ggplot(subset(sig.cut.df,category %in% c(T,F) & gc==5),aes(x=Read_pos,fill=category))+geom_histogram(position='dodge')


cut.read.df<-subset(cut.df,Read_pos>32 & Read_pos<94)

h.cut.read.df<-hiseq.roc(cut.read.df,possible_tp,possible_vars)

ggplot(subset(h.cut.read.df,gc==4),aes(x=1-adj.specificity,y=adj.sensitivity))+geom_step(aes(color=exp.freq),size=2)+scale_color_brewer(palette = "Set1")+xlab("1-Specificity")+ylab("Sensitivity")+guides(color=guide_legend(title="Frequency"))+scale_y_continuous(limits=c(0,1))


h.cut.read.table<-hiseq.roc.table(cut.read.df,0.001,possible_tp,possible_vars)

knitr::kable(subset(h.cut.read.table,gc==5))

```

